---
title: "Friday Q&A 2017-06-30: 深入理解 ARM64 中的 objc_msgSend 实现"
description: WWDC 期间，我在 CocoaConf Next Door 上发言，其中一个专题的内容是关于 objc_msgSend 在 ARM64 架构中的实现。所以决定将其撰写成一篇文章并加入至 Friday Q&A 专题中。
header: "Friday Q&A 2017-06-30: 深入理解 ARM64 中的 objc_msgSend 实现"
author: 冬瓜
---


原文：[Dissecting objc_msgSend on ARM64](https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html)

---

我们回来了！WWDC 期间，我在 CocoaConf Next Door 上发言，其中一个专题的内容是关于 `objc_msgSend` 在 ARM64 架构中的实现。所以决定将其撰写成一篇文章并加入至 Friday Q&A 专题中。

## 总览

每一个 Objective-C 对象都拥有一个类，每个类都有自己的方法列表。每个方法都拥有选择子、一个指向实现的函数指针和一些元数据（metadata）。`objc_msgsend` 的工作是使用对象和选择子来查询对应的函数指针，从而跳转到该方法的位置中。

查找的方法可能十分复杂。如果一个方法在当前类中无法查询，那么可能需要在其父类中继续查询。当在父类中也无法找到，则开始调用 runtime 中的消息转发机制。如果这是发送到该类的第一条信息，那么它将会调用该类的 `+initialize` 方法。

一般情况下，查找的方法需要迅速完成。这与其复杂的查找机制似乎是矛盾的。

Objective-C 解决这个矛盾的方法是利用**方法缓存(Method Cache)**。每个类都有一个缓存，它将方法存储为一组选择子和函数指针，在 Objective-C 中被称为 IMP。它们被组织成哈希表的结构，所以查找速度十分迅速。当需要查找方法时，runtime 首先会查询缓存。如果结构不被命中，则开始那一套复杂的查询过程，并将结果存储至缓存，以便下次快速查询。

`objc_msgSend` 是使用汇编语言编写的。其原因是：其一是使用纯 C 是无法编写一个携带未知参数并跳转至任意函数指针的方法。单纯从语言角度来讲，也没有必要增加这样的功能。其二，对于 `objc_msgSend` 来说速度是最重要的，只用汇编来实现是十分高效的。

当然，我们也不希望所有的查询过程都是通过汇编来实现。一旦启用了非汇编语言那么就会降低速度。所以我们将消息分成了两个部分，即 `objc_msgSend` 的高速路径(fast path)，此处所有的实现使用的是汇编语言，以及缓慢路径(slow path)部分，此处的实现手段均为 C 语言。在高速路径中我们可以查询方法指针的缓存表，如果找到直接跳转。否则，则使用 C 代码来处理这次查询。

因此，整个 `objc_msgSend` 的过程大体如下：

1. 获取传入对象所属的类。
2. 获取该类的方法缓存表。
3. 使用传入的选择子在缓存中查询。
4. 如果缓存中不存在，则调用 C 的慢速代码段。
5. 跳转至 `IMP` 映射位置的方法。

具体是怎么实现的呢？下面开始分析。

## 导读

`objc_msgSend` 不同的情况有不同的执行路径。从中包含了处理如消息为 `nil`(messages to nil)，*Tagged pointer* 以及哈希表冲突的特殊代码。首相，先来看一个最常见最直观的情况，即消息发送到 `non-nil` 和 `non-tagged` 的情况，并且该指定函数指针在哈希表中可以直接获得。这里我将会记录遇到这些判断节点的各种情况，之后当我们到达运行终点后在回头看看其他情况。

我将会列出每个指令(instruction)或指令集(group of instructions)，然后讲述它的功能以及调用原因。仅仅去理解每一条提及的指令即可。

每个指令前面都有一个偏移地址。他们就好比一个量化器，来告知程序跳转的位置。

ARM64 有 31 个 64 位寄存器。他们的位置符号从 `x0` 到 `x30`。当然也可以使用寄存器中 `w0` 到 `w30` 的低 32 位，他们也是可独立使用的。`x0` 到 `x7` 前八位用于传递一个函数。这意味着 `objc_msgSend` 在 `x0` 中接收到选择子，在 `x1` 中接收 `_cmd` 参数。

```x8086
0x0000 cmp     x0, #0x0
0x0004 b.le    0x6c
```

如果此处的值小于或等于 0，则 self 与 0 的比较，并在其他位置进行跳转。零代表着 `nil`，因此这会使得转发的消息也赋为 `nil`。这也是处理 `Tagged Pointers` 的方案。`Tagged Pointers` 在 ARM64 上通过在高位来存储数据。（不同于 x86-64 ，其是在低位进行存储。）当高位被占用时，则被解释为存储的是一个有符号整数，且为负。当仅仅是普通指针的情况，程序不会运行到此处。

```x8086
0x0008 ldr    x13, [x0]
```

> 译者注：ARM 中的 `LDR` 为加载指令。`LDR   R0，[R1]` 的意思是 **将存储器地址为 R1 的字数据读入存储器 R0**。`LDR` 指令用于从存储器中将一个 32 （ARM64 架构则为 64 位，后者相同）位字数据传送到目的存储器中。该指令通常用于存储器中读取 32 位的字数据套通用寄存器中，然后对数据进行处理。

此处是通过 x0 寄存器指向的 64 位字数据来加载 `self` 的 isa。`x13` 寄存器现在则存储着 `isa` 指针。